PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;
TOKENS_ARE_NODES=false;

SKIP : " " | "\t" | "\r" | "\n" |  <"//" (~["\n"])* "\n"> |  < "/*"(~["*"])* "*"(~["/"] (~["*"])* "*")* "/" > ;

TOKEN :
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |
	< OPEN_PAREN : "(" > |
	< CLOSE_PAREN : ")" > |
	< INTEGER : (["0" - "9"])+ > |
	< IMPORT : "import" > |
	< DOT : "." > |
	< SEMICOLON : ";" > |
	< CLASS : "class" > |
	< EXTENDS : "extends" > |
	< OPEN_CURLY_BRA : "{" > |
	< CLOSE_CURLY_BRA : "}" > |
	< PUBLIC : "public" > |
	< COMMA : "," > |
	< RETURN : "return" > |
	< STATIC : "static" > |
	< VOID : "void" > |
	< MAIN : "main" > |
	< STRING : "String" > |
	< OPEN_SQUARE_BRA : "[" > |
	< CLOSE_SQUARE_BRA : "]" > |
    < INT : "int" > |
    < BOOLEAN : "boolean" > |
    < IF : "if" > |
    < ELSE : "else" > |
    < WHILE : "while" > |
    < ASSIGN : "=" > |
    < AND : "&&" > |
    < MINOR : "<" > |
    < LENGTH : "length" > |
    < TRUE : "true" > |
    < FALSE : "false" > |
    < THIS : "this" > |
    < NEW : "new" > |
    < NOT : "!" > |
    < ID : (["a"-"z"] | "_" | ["A"-"Z"]) (["a"-"z"] | ["A"-"Z"] | "_" | ["0"-"9"])* >;

Start : (ImportDeclaration)* ClassDeclaration <EOF>;

Identifier #id_: <ID> ({jjtThis.put("", lastConsumedToken.getImage());});

ImportDeclaration #import_:  <IMPORT> Identifier (<DOT> Identifier)* <SEMICOLON>;

ClassDeclaration #class_: <CLASS> Identifier (<EXTENDS> Identifier)? <OPEN_CURLY_BRA> (VarDeclaration)* (MethodDeclaration)* <CLOSE_CURLY_BRA>;

VarDeclaration #var_: SCAN 2 (Type Identifier <SEMICOLON>);

MethodDeclaration #method_: <PUBLIC> ((
                    Type Identifier <OPEN_PAREN> (Type Identifier ( <COMMA> Type Identifier)* )? <CLOSE_PAREN>
                    <OPEN_CURLY_BRA>
                    ( VarDeclaration )*
                    ( Statement )*
                    <RETURN> Expression <SEMICOLON>
                    <CLOSE_CURLY_BRA>) | (
                    <STATIC> <VOID> <MAIN> #main_ <OPEN_PAREN> <STRING> <OPEN_SQUARE_BRA><CLOSE_SQUARE_BRA> Identifier <CLOSE_PAREN>
                    <OPEN_CURLY_BRA>
                    ( VarDeclaration )*
                    ( Statement )*
                    <CLOSE_CURLY_BRA>));

Type #type_: <INT> (<OPEN_SQUARE_BRA> <CLOSE_SQUARE_BRA>)? |
      <BOOLEAN> |
      Identifier |
      <STRING> #string_ ;



Statement #statement_: <OPEN_CURLY_BRA> ( Statement )* <CLOSE_CURLY_BRA> |
           <IF> #if_ <OPEN_PAREN> Expression <CLOSE_PAREN> Statement <ELSE> #else_ Statement |
           <WHILE> #while_ <OPEN_PAREN> Expression <CLOSE_PAREN> Statement |
           SCAN 2 (Identifier  (
           (<ASSIGN> #assign_ Expression <SEMICOLON>) |
           (<OPEN_SQUARE_BRA> Expression <CLOSE_SQUARE_BRA> <ASSIGN>  #assign_ Expression <SEMICOLON>)
           )) |
           SCAN 2 (Expression <SEMICOLON>);

Expression #expr_: Expr |
                <DOT> (<LENGTH> | (Identifier <OPEN_PAREN> ( Expression (<COMMA> Expression)* )? <CLOSE_PAREN>)) |
                <NEW> ((<INT> <OPEN_SQUARE_BRA> Expression <CLOSE_SQUARE_BRA>) | (Identifier <OPEN_PAREN> <CLOSE_PAREN>));

Expr : LogicalExpr;

LogicalExpr: CompareExpr (<AND> CompareExpr)*;

CompareExpr: AddExpr (<MINOR> AddExpr)*;

AddExpr:  MultiplyExpr ((<PLUS> | <MINUS>) MultiplyExpr)*;

MultiplyExpr: NotExpr ((<TIMES> | <DIVIDE>) NotExpr)*;

NotExpr: (<NOT>)? ArrayAccess;

ArrayAccess: ExprTerminal (<OPEN_SQUARE_BRA> Expr <CLOSE_SQUARE_BRA>)*;

ExprTerminal: IntLiteral | <OPEN_PAREN> Expression <CLOSE_PAREN> | Identifier | <TRUE> | <FALSE> | <THIS>;

IntLiteral: <INTEGER> ({jjtThis.put("value", lastConsumedToken.getImage());});

// Injections for the implementation of JmmNode
// Since this is injected into BaseNode, it affects only non-terminals
INJECT BaseNode :
        import pt.up.fe.comp.jmm.ast.JmmNode;
        import pt.up.fe.comp.jmm.ast.JmmNodeImpl;
        import pt.up.fe.comp.jmm.ast.AJmmNode;
        import pt.up.fe.specs.util.SpecsCollections;
        extends AJmmNode
{
    @Override
    public List<JmmNode> getChildren() {

        return SpecsCollections.cast(children(), JmmNode.class);
    }

    @Override
    public void add(JmmNode child, int index) {

        if (child instanceof Node) {

            addChild(index, (Node) child);
        } else {

            throw new RuntimeException("Node " + child + " is not a Node.");
        }

    }
}
