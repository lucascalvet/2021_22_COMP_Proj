PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;
TOKENS_ARE_NODES=false;

SKIP : " " | "\t" | "\r" | "\n" |  <"//" (~["\n"])* "\n"> |  < "/*"(~["*"])* "*"(~["/"] (~["*"])* "*")* "/" > ;

TOKEN :
	< PLUS_ : "+" > |
	< MINUS_ : "-" > |
	< TIMES_ : "*" > |
	< DIVIDE_ : "/" > |
	< OPEN_PAREN_ : "(" > |
	< CLOSE_PAREN_ : ")" > |
	< INTEGER_ : (["0" - "9"])+ > |
	< IMPORT_ : "import" > |
	< DOT_ : "." > |
	< SEMICOLON_ : ";" > |
	< CLASS_ : "class" > |
	< EXTENDS_ : "extends" > |
	< OPEN_CURLY_BRA_ : "{" > |
	< CLOSE_CURLY_BRA_ : "}" > |
	< PUBLIC_ : "public" > |
	< COMMA_ : "," > |
	< RETURN_ : "return" > |
	< STATIC_ : "static" > |
	< VOID_ : "void" > |
	< MAIN_ : "main" > |
	< STRING_ : "String" > |
	< OPEN_SQUARE_BRA_ : "[" > |
	< CLOSE_SQUARE_BRA_ : "]" > |
    < INT_ : "int" > |
    < BOOLEAN_ : "boolean" > |
    < IF_ : "if" > |
    < ELSE_ : "else" > |
    < WHILE_ : "while" > |
    < ASSIGN_ : "=" > |
    < AND_ : "&&" > |
    < MINOR_ : "<" > |
    < LENGTH_ : "length" > |
    < TRUE_ : "true" > |
    < FALSE_ : "false" > |
    < THIS_ : "this" > |
    < NEW_ : "new" > |
    < NOT_ : "!" > |
    < ID_ : (["a"-"z"] | "_" | ["A"-"Z"]) (["a"-"z"] | ["A"-"Z"] | "_" | ["0"-"9"])* >;

Start #Program: (ImportDeclaration)* ClassDeclaration <EOF>;

Identifier #Id: <ID_> ({jjtThis.put("name", lastConsumedToken.getImage());});

ImportDeclaration #Import:  <IMPORT_> Identifier (<DOT_> Identifier)* <SEMICOLON_>;

ClassDeclaration #ClassDecl: <CLASS_> Identifier (<EXTENDS_> Identifier)? <OPEN_CURLY_BRA_> (VarDeclaration)* (MethodDeclaration)* <CLOSE_CURLY_BRA_>;

VarDeclaration #Var: SCAN 2 (Type Identifier <SEMICOLON_>);

MethodDeclaration #MethodDecl: <PUBLIC_> ((
                    Type Identifier <OPEN_PAREN_> (Type Identifier ( <COMMA_> Type Identifier)* )? <CLOSE_PAREN_>
                    <OPEN_CURLY_BRA_>
                    ( VarDeclaration )*
                    ( Statement )*
                    <RETURN_> Expression <SEMICOLON_>
                    <CLOSE_CURLY_BRA_>) | (
                    <STATIC_> <VOID_> <MAIN_> #main <OPEN_PAREN_> <STRING_> <OPEN_SQUARE_BRA_><CLOSE_SQUARE_BRA_> Identifier <CLOSE_PAREN_>
                    <OPEN_CURLY_BRA_>
                    ( VarDeclaration )*
                    ( Statement )*
                    <CLOSE_CURLY_BRA_>));

Type #Type: <INT_> ({jjtThis.put("type", lastConsumedToken.getImage());}) (<OPEN_SQUARE_BRA_> <CLOSE_SQUARE_BRA_>)? |
      <BOOLEAN_> #bool_type |
      Identifier |
      <STRING_> #string ;

Statement #Statement: <OPEN_CURLY_BRA_> ( Statement )* <CLOSE_CURLY_BRA_> |
           <IF_> #If <OPEN_PAREN_> Expression <CLOSE_PAREN_> Statement <ELSE_> #Else Statement |
           <WHILE_> #While <OPEN_PAREN_> Expression <CLOSE_PAREN_> Statement |
           SCAN 2 (Identifier  (
           (<ASSIGN_> #Assign Expression <SEMICOLON_>) |
           (<OPEN_SQUARE_BRA_> Expression <CLOSE_SQUARE_BRA_> <ASSIGN_>  #Assign Expression <SEMICOLON_>)
           )) |
           SCAN 2 (Expression <SEMICOLON_>);

Expression #void: LogicalExpr;

LogicalExpr #void: CompareExpr (<AND_> CompareExpr #And(2))*;

CompareExpr #void: AddExpr (<MINOR_> AddExpr #Lower(2))*;

AddExpr #void:  MultiplyExpr (<PLUS_> MultiplyExpr #Add(2) | <MINUS_> MultiplyExpr #Subtract(2))*;

MultiplyExpr #void: NewExpr (<TIMES_> NewExpr #Multiply(2) | <DIVIDE_> NewExpr #Divide(2))*;

NewExpr #void: NotExpr | (<NEW_> ((<INT_> #Int_type <OPEN_SQUARE_BRA_> Expression <CLOSE_SQUARE_BRA_>) | (Identifier <OPEN_PAREN_> <CLOSE_PAREN_>))  #New);

NotExpr #void: ArrayAccess | <NOT_> NotExpr #Not;

ArrayAccess #void: AccessExpr (<OPEN_SQUARE_BRA_> Expression  <CLOSE_SQUARE_BRA_> #Array_access)*;

AccessExpr #void: ExprTerminal (<DOT_>  (<LENGTH_> #Length | (Identifier <OPEN_PAREN_> ( Expression (<COMMA_> Expression)* )? <CLOSE_PAREN_>)) #Access(2))*;

ExprTerminal #void: IntLiteral | <OPEN_PAREN_> Expression <CLOSE_PAREN_> | Identifier | <TRUE_> #True | <FALSE_> #False | <THIS_> #This;

IntLiteral #Int: <INTEGER_> ({jjtThis.put("value", lastConsumedToken.getImage());});

// Injections for the implementation of JmmNode
// Since this is injected into BaseNode, it affects only non-terminals
INJECT BaseNode :
        import pt.up.fe.comp.jmm.ast.JmmNode;
        import pt.up.fe.comp.jmm.ast.JmmNodeImpl;
        import pt.up.fe.comp.jmm.ast.AJmmNode;
        import pt.up.fe.specs.util.SpecsCollections;
        extends AJmmNode
{
    @Override
    public List<JmmNode> getChildren() {

        return SpecsCollections.cast(children(), JmmNode.class);
    }

    @Override
    public void add(JmmNode child, int index) {

        if (child instanceof Node) {

            addChild(index, (Node) child);
        } else {

            throw new RuntimeException("Node " + child + " is not a Node.");
        }

    }
}
