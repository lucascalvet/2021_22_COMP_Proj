PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;
TOKENS_ARE_NODES=false;

SKIP : " " | "\t" | "\r" | "\n" |  <"//" (~["\n"])* "\n"> |  < "/*"(~["*"])* "*"(~["/"] (~["*"])* "*")* "/" > ;

TOKEN :
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |
	< OPEN_PAREN : "(" > |
	< CLOSE_PAREN : ")" > |
	< INTEGER : (["0" - "9"])+ > |
	< IMPORT : "import" > |
	< DOT : "." > |
	< SEMICOLON : ";" > |
	< CLASS : "class" > |
	< EXTENDS : "extends" > |
	< OPEN_CURLY_BRA : "{" > |
	< CLOSE_CURLY_BRA : "}" > |
	< PUBLIC : "public" > |
	< COMMA : "," > |
	< RETURN : "return" > |
	< STATIC : "static" > |
	< VOID : "void" > |
	< MAIN : "main" > |
	< STRING : "String" > |
	< OPEN_SQUARE_BRA : "[" > |
	< CLOSE_SQUARE_BRA : "]" > |
    < INT : "int" > |
    < BOOLEAN : "boolean" > |
    < IF : "if" > |
    < ELSE : "else" > |
    < WHILE : "while" > |
    < ASSIGN : "=" > |
    < AND : "&&" > |
    < MINOR : "<" > |
    < LENGTH : "length" > |
    < TRUE : "true" > |
    < FALSE : "false" > |
    < THIS : "this" > |
    < NEW : "new" > |
    < NOT : "!" > |
    < ID : (["a"-"z"] | "_" | ["A"-"Z"]) (["a"-"z"] | ["A"-"Z"] | "_" | ["0"-"9"])* >;

Start : ImportDeclaration ClassDeclaration <EOF>;

ImportDeclaration :  (<IMPORT> <ID> (<DOT> <ID>)* <SEMICOLON>)*;


ClassDeclaration : <CLASS> <ID> (<EXTENDS> <ID>)? <OPEN_CURLY_BRA> (VarDeclaration)* (MethodDeclaration)* <CLOSE_CURLY_BRA>;

VarDeclaration : SCAN 2 (Type <ID> <SEMICOLON>);

MethodDeclaration : <PUBLIC> ((
                    Type <ID> <OPEN_PAREN> (Type <ID> ( <COMMA> Type <ID>)* )? <CLOSE_PAREN>
                    <OPEN_CURLY_BRA>
                    ( VarDeclaration )*
                    ( Statement )*
                    <RETURN> Expression <SEMICOLON>
                    <CLOSE_CURLY_BRA>) | (
                    <STATIC> <VOID> <MAIN> <OPEN_PAREN> <STRING> <OPEN_SQUARE_BRA><CLOSE_SQUARE_BRA> <ID> <CLOSE_PAREN>
                    <OPEN_CURLY_BRA>
                    ( VarDeclaration )*
                    ( Statement )*
                    <CLOSE_CURLY_BRA>));

Type : <INT> (<OPEN_SQUARE_BRA> <CLOSE_SQUARE_BRA>)? |
      <BOOLEAN> |
      <ID> |
      <STRING> ;

Statement : <OPEN_CURLY_BRA> ( Statement )* <CLOSE_CURLY_BRA> |
           <IF> <OPEN_PAREN> Expression <CLOSE_PAREN> Statement <ELSE> Statement |
           <WHILE> <OPEN_PAREN> Expression <CLOSE_PAREN> Statement |
           SCAN 2 (<ID> (
           (<ASSIGN> Expression <SEMICOLON>) |
           (<OPEN_SQUARE_BRA> Expression <CLOSE_SQUARE_BRA> <ASSIGN> Expression <SEMICOLON>)
           )) |
           SCAN 2 (Expression <SEMICOLON>);


Expression : <INTEGER> (ExprNLR)? |
            <TRUE> (ExprNLR)? |
            <FALSE> (ExprNLR)? |
            <ID> (ExprNLR)? |
            <THIS> (ExprNLR)? |
            <NEW> (
            (<INT> <OPEN_SQUARE_BRA> Expression <CLOSE_SQUARE_BRA> (ExprNLR)?) |
            (<ID> <OPEN_PAREN> <CLOSE_PAREN> (ExprNLR)?)
            ) |
            <NOT> Expression (ExprNLR)? |
            <OPEN_PAREN> Expression <CLOSE_PAREN> (ExprNLR)?;

ExprNLR #void : (<AND> | <MINOR> | <PLUS> | <MINUS> | <TIMES> | <DIVIDE>) Expression (ExprNLR)? |
          <OPEN_SQUARE_BRA> Expression <CLOSE_SQUARE_BRA> (ExprNLR)? |
          <DOT> (
          (<LENGTH> (ExprNLR)?) |
          (<ID> <OPEN_PAREN> ( Expression (<COMMA> Expression)* )? <CLOSE_PAREN> (ExprNLR)?)
          );
